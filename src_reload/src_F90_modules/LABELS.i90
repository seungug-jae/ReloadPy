# 1 "/home/neutron0/a/jae/ReloadPy/src_reload/src_F90_modules/LABELS.F90"
!---------------------------------------------------------------------------------------------------------------------------------
!  Using the historical format for the LABELS file, import the data from the binary file
!  Notes: This file format is a complete disaster...whoever came up with it should be shot.
!---------------------------------------------------------------------------------------------------------------------------------
!  LABELS_AssignPrintInfo  !  Sets the output unit and debugprint level settings for the module
!  LABELS_IdentifyZone     !  Searches through the list of zones and sub-zones to identify a given zone
!  LABELS_IdentifyRegion   !  Searches through the list of regions to identify a given region name
!  LABELS_IdentifyArea     !  Searches through the list of regions to identify a given area name
!  LABELS_ApplyDIF3Dfix    !  Applies NE_Kind_DIF3DCharacterFix to all of the labels
!  LABELS_Define           !  Defines a LABELS_DATA type based upon user input
!  LABELS_Void             !  Provides a path to deallocate the data
!  LABELS_Copy             !  Copies the data structure
!  LABELS_PRINT            !  Prints the LABELS data
! -------------------------
!  LABELS_AssignPrintInfo(MODULE_OUTPUT_UNIT)
!  LABELS_IdentifyZone(User_LABELS,User_ZoneName)
!  LABELS_IdentifyRegion(User_LABELS,User_RegionName)
!  LABELS_IdentifyArea(User_LABELS,User_AreaName)
!  LABELS_ApplyDIF3Dfix(User_LABELS)
!  LABELS_Define(User_LABELS,NTZSZ,NREG,NAREA,LREGA,NHTS1,NHTS2,NSETS,NALIAS,NTRI,NRING,NCHAN,   &
!                     NBANKS,LINTAX,MAXTIM,MAXROD,MAXMSH,MAXLRD,MAXLCH,NVARY,MAXBRN,MAXORD,ND)
!  LABELS_Void(User_LABELS)
!  LABELS_Copy(Source_LABELS,Dest_LABELS)
!  LABELS_PRINT(User_LABELS)
!---------------------------------------------------------------------------------------------------------------------------------
MODULE LABELS_io
# 1 "/home/neutron0/a/jae/ReloadPy/src_reload/src_F90_modules/DIF3D_Types.h" 1 
!  Copyright(c) 2005 Argonne National Laboratory
!  This header file is used to control the data set assignments in the DIF3D code
!     8 bit INTEGER -128 to 128
!    16 bit INTEGER -32,768 to 32,767
!    32 bit INTEGER -2,147,483,648 to 2,147,483,647
!    64 bit INTEGER -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807
!   128 bit INTEGER why?
!    32 bit REAL 1.17549435E-38 to 3.40282347E38
!    64 bit REAL 2.2250738585072013D-308 to 1.7976931348623158D308
!   128 bit REAL 6.4751751194380251109244389582276465524996Q-4966 to 1.189731495357231765085759326628007016196477Q4932
!
!
! DIF3D wide
! --------------
!#define DIF3D_Debug





























!  Variable definitions















! NUBOW

! Processor Angle-Space decomposition style
! #define DIF3D_OLDPROCSETUP

!  The matching byte size definitions














! BUILD ZPR Model


! ISOTXS
! --------------
! #define ISOTXS_Debug
!  Fixed constants


!  Variable definitions



!  The matching byte size definitions




! DLAYXS
! --------------
! #define DLAYXS_Debug
!  Variable definitions



!  The matching byte size definitions




! COMPXS
! --------------
! #define COMPXS_Debug
!  Variable definitions



!  The matching byte size definitions




! GEODST
! --------------
! #define GEODST_Debug
!  Variable definitions




!  The matching byte size definitions





! LABELS
! --------------
! #define LABELS_Debug
!  Variable definitions



!  The matching byte size definitions




! FIXSRC
! --------------
! #define FIXSRC_Debug
!  Variable definitions



!  The matching byte size definitions




! NDXSRF
! --------------
! #define NDXSRF_Debug
!  Variable definitions



!  The matching byte size definitions




! PWDINT
! --------------
! #define PWDINT_Debug
!  Variable definitions



!  The matching byte size definitions




! RTFLUX
! --------------
! #define RTFLUX_Debug
!  Variable definitions



!  The matching byte size definitions




! RMFLUX
! --------------
! #define RTFLUX_Debug
!  Variable definitions



!  The matching byte size definitions




! RZMFLX
! --------------
! #define RZMFLX_Debug
!  Variable definitions



!  The matching byte size definitions




! NHFLUX
! --------------
! #define NHFLUX_Debug
!  Variable definitions




!  The matching byte size definitions





! RCTDEN
! --------------
! #define RCTDEN_Debug
!  Variable definitions




!  The matching byte size definitions





! RCTFLX
! --------------
! #define RCTFLX_Debug
!  Variable definitions




!  The matching byte size definitions





! RCTPWD
! --------------
! #define RCTPWD_Debug
!  Variable definitions




!  The matching byte size definitions





! ZNATDN
! --------------
! #define ZNATDN_Debug
!  Variable definitions



!  The matching byte size definitions




! NE_FreeForm
! --------------
! #define NE_FreeForm_Debug
!  Fixed constants






!  Variable definitions





!  The matching byte size definitions






! Large Memory Array (LMA)
! --------------
!#define NE_LMA_Debug










! The maximum number of 8 byte words in a LMA file
! Note that 1 TB or 1024*1024 is the typical disk size as of 9/2012



! PERSENT
! --------------































































! PERSENT
! --------------



! COMMARA
! --------------- Compare with the above











! MovingFuel code



# 28 "/home/neutron0/a/jae/ReloadPy/src_reload/src_F90_modules/LABELS.F90" 2 
IMPLICIT NONE

TYPE LABELS_DATA
   LOGICAL(KIND=4)  :: Defined  = .FALSE.
   CHARACTER*128       :: FILENAME = 'UNDEFINE'  ! Originating file name
! CARD TYPE 0
   CHARACTER*8        :: HNAME    = 'UNDEFINE'
   CHARACTER*8        :: HUSE(2)  = 'UNDEFINE'
   INTEGER(KIND=4) :: IVERS    = 0
! CARD TYPE 1
! THE AXIAL DIMENSION IS Z IN RZ, XYZ, HEX-Z AND TRIANGULAR-Z GEOMETRIES.  IT IS Y IN XY GEOMETRY.
   INTEGER(KIND=4) :: NTZSZ    ! NUMBER OF ZONES AND SUBZONES
   INTEGER(KIND=4) :: NREG     ! NUMBER OF REGIONS
   INTEGER(KIND=4) :: NAREA    ! NUMBER OF AREAS
   INTEGER(KIND=4) :: LREGA    ! LENGTH OF NRA ARRAY
   INTEGER(KIND=4) :: NHTS1    ! NUMBER OF HALF-HEIGHT AND EXTRAPOLATION DISTANCE SPECIFICATIONS {0 - NONE,1 - SINGLE VALUE USED EVERYWHERE, .EQ.NREG - REGION DEPENDENT)
   INTEGER(KIND=4) :: NHTS2    ! NUMBER OF HALF-HEIGHT AND EXTRAPOLATION DISTANCE SPECIFICATIONS FOR THE SECOND DIRECTION. {SAME DEFINITION AS NHTS1}
   INTEGER(KIND=4) :: NSETS    ! NUMBER OF NUCLIDE SETS
   INTEGER(KIND=4) :: NALIAS   ! 0 IF RECORD 5D IS NOT PRESENT.  IF GREATER THAN 0, RECORD 5D IS PRESENT AND THE ALIAS ARRAY IS OF LENGTH NALIAS.
   INTEGER(KIND=4) :: NTRI     ! NO. OF TRIANGLES PER HEX FOR TRIANGULAR GEOMETRIES
   INTEGER(KIND=4) :: NRING    ! MAX. NO. OF RINGS OF HEXAGONS FOR TRIANGULAR GEOMETRIES
   INTEGER(KIND=4) :: NCHAN    ! NO. OF CONTROL-ROD CHANNELS IN THE MODEL.  NCHAN IS THE SUM OF NRODS (RECORD 6D) OVER ALL CONTROL ROD BANKS.
   INTEGER(KIND=4) :: NBANKS   ! NO. OF CONTROL-ROD BANKS
   INTEGER(KIND=4) :: LINTAX   ! ORIGINAL NO. OF FINE MESH INTERVALS IN AXIAL DIMENSION
   INTEGER(KIND=4) :: MAXTIM   ! MAXIMUM VALUE OF NTIMES(I) (I=1,NBANKS)
   INTEGER(KIND=4) :: MAXROD   ! MAXIMUM VALUE OF NRODS(I) (I=1,NBANKS)
   INTEGER(KIND=4) :: MAXMSH   ! MAXIMUM VALUE OF NMESH(K) (K=1,LRODS;I=1,NBANKS) WHERE LRODS=NRODS(I)
   INTEGER(KIND=4) :: MAXLRD   ! MAXIMUM VALUE OF LENROD(K) (K=1,LRODS;I=1,NBANKS)
   INTEGER(KIND=4) :: MAXLCH   ! MAXIMUM VALUE OF LENCHN(K) (K=1,LRODS;I=1,NBANKS)
   INTEGER(KIND=4) :: NVARY    ! NUMBER OF BURNUP DEPENDENT ISOTOPES
   INTEGER(KIND=4) :: MAXBRN   ! THE MAXIMUM NUMBER OF GROUPS THAT ARE BURNUP DEPENDENT FOR ANY OF THE BURNUP DEPENDENT ISOTOPES
   INTEGER(KIND=4) :: MAXORD   ! THE HIGHEST ORDER POLYNOMIAL FIT FOR ANY OF THE GROUPS FOR ANY OF THE BURNABLE ISOTOPES
   INTEGER(KIND=4) :: ND       ! 1 IN XY AND RZ GEOMETRIES, 2 IN XYZ, R-THETA-Z, THETA-R-Z, HEX-Z, AND TRIANGULAR-Z MODELS
   INTEGER(KIND=4) :: IDUM(2)  ! RESERVED
! CARD TYPE 2
   CHARACTER*8,       DIMENSION(:),POINTER :: CMPNAM  ! NTZSZ    ZONE OR SUBZONE LABEL. SUBZONES FOLLOW ZONES
   CHARACTER*8,       DIMENSION(:),POINTER :: REGNAM  ! NREG     REGION LABEL
   CHARACTER*8,       DIMENSION(:),POINTER :: ARANAM  ! NAREA    AREA LABEL
   INTEGER(KIND=4),DIMENSION(:),POINTER :: NRA     ! LREGA    REGION/AREA ASSIGNMENTS.   NRA(N(J)) IS THE NUMBER OF REGIONS IN AREA J.
!          N(1)=1      N(J+1)=N(J)+1+NRA(N(J))
!          LREGA=SUM[1+NRA(N(J))] FOR J=1,NAREA
!          (NRA(I),I=N(J)+1,N(J+1)-1) A LIST OF THE REGION NUMBERS FOR THOSE REGIONS.
! CARD TYPE 3  FINITE-GEOMETRY TRANSVERSE DISTANCES (PRESENT IF NHTS1.GT.0 OR NHTS2.GT.0)
   REAL(KIND=8),DIMENSION(:),POINTER :: HAFHT1  ! NHTS1    ACTUAL TRANSVERSE HALF HEIGHT FOR REGION I
!          IF HAFHTN(I)+XTRAPN(I)=0.0 (N =1 OR 2)
!          THE MODEL IS TREATED AS EXTENDING TO INFINITY IN THE NTH TRANSVERSE DIMENSION.
   REAL(KIND=8),DIMENSION(:),POINTER :: XTRAP1  ! NHTS1    TRANSVERSE EXTRAPOLATION DISTANCE FOR REGION I
   REAL(KIND=8),DIMENSION(:),POINTER :: HAFHT2  ! NHTS2    ACTUAL TRANSVERSE HALF HEIGHT FOR REGION I IN THE SECOND DIRECTION
   REAL(KIND=8),DIMENSION(:),POINTER :: XTRAP2  ! NHTS2    TRANSVERSE EXTRAPOLATION DISTANCE FOR REGION I IN THE SECOND DIRECTION
! CARD TYPE 4  NUCLIDE SET LABELS  (PRESENT IF NSETS.GT.1)
   CHARACTER*8,       DIMENSION(:),POINTER :: SETISO  ! NSETS
! CARD TYPE 5  ALIAS ZONE LABELS   (PRESENT IF NALIAS .GT. 0)
   CHARACTER*8,       DIMENSION(:),POINTER :: ALIAS   ! NALIAS
!  FOR REBUS-3, THE ZONES ARE PROLIFERATED TO REGIONS THEREBY DEFINING THE REGION LABELS. ALIAS CONTAINS THE ORIGINAL ZONE -> REGION LABELS.
! CARD TYPE 6  GENERAL CONTROL-ROD MODEL DATA (PRESENT IF NBANKS .GT. 0)
   CHARACTER*8,       DIMENSION(:),POINTER :: BNKLAB  ! NBANKS   CONTROL-ROD BANK LABEL
   REAL(KIND=8),DIMENSION(:),POINTER :: ZMESHO  ! LINTAX   ORIGINAL LAST-DIMENSION MESH STRUCTURE
! ZMESHO(1)=0.0.  THE ZMESHO ARRAY MUST AT LEAST CONTAIN ALL THE BOUNDARIES BETWEEN DISSIMILAR MR ARRAYS
! THE ZMESHO ARRAY IN A LABELS FILE CREATED BY GNIP4C WILL NORMALLY CONTAIN THE ORIGINAL, COARSE-MESH BOUNDARIES.
   REAL(KIND=8),DIMENSION(:),POINTER :: POSBNK  ! NBANKS   CURRENT POSITION OF ROD BANK I
   INTEGER(KIND=4),DIMENSION(:),POINTER :: NRODS   ! NBANKS   NO. OF RODS IN BANK I
   INTEGER(KIND=4),DIMENSION(:),POINTER :: NTIMES  ! NBANKS   NO. OF TIME NODES IN POSITION VS. TIME TABLE FOR BANK I
   INTEGER(KIND=4),DIMENSION(:),POINTER :: KFINTO  ! LINTAX-1    ORIGINAL NUMBER OF FINE MESH BETWEEN ZMESHO(I) AND ZMESHO(I+1)
! CARD TYPE 7           CONTROL-ROD BANK DATA (PRESENT IF NBANKS .GT. 0)
   REAL(KIND=8),DIMENSION(:,:),POINTER :: RBTIME   ! MAXTIM,NBANKS   TIME ENTRIES IN ROD POSITION VS. TIME TABLE
   REAL(KIND=8),DIMENSION(:,:),POINTER :: RBPOS    ! MAXTIM,NBANKS   ROD-BANK POSITIONS IN TABLE (CM.)
   INTEGER(KIND=4),DIMENSION(:,:),POINTER :: NMESH    ! MAXROD,NBANKS   NO. OF PLANAR MESH CELLS IN ROD K OF CURRENT ROD BANK
   INTEGER(KIND=4),DIMENSION(:,:),POINTER :: LENCHN   ! MAXROD,NBANKS   NO. OF REGIONS Defined FOR THE IMMOVABLE PORTION OF ROD CHANNEL K
   INTEGER(KIND=4),DIMENSION(:,:),POINTER :: LENROD   ! MAXROD,NBANKS   NO. OF REGIONS Defined FOR THE MOVEABLE PORTION OF ROD CHANNEL K
! CARD TYPE 8           CONTROL-ROD CHANNEL DATA (PRESENT IF LLCHN + LLROD + MMESH .GT. 0)
   REAL(KIND=8),DIMENSION(:,:,:),  POINTER :: POSCHN  ! MAXLCH,MAXROD,NBANKS    POSITION (RELATIVE TO THE BOTTOM) OF THE LOWER BOUNDARY OF REGION L
!                   IN THE IMMOVABLE PORTION OF THE CURRENT ROD CHANNEL (POSCHN(1)=0.0)
   REAL(KIND=8),DIMENSION(:,:,:),  POINTER :: POSROD  ! MAXLRD,MAXROD,NBANKS    POSITION (RELATIVE TO ROD TIP) OF THE LOWER BOUNDARY OF REGION L
!                   IN THE MOVEABLE PORTION OF THE CURRENT ROD CHANNEL (POSROD(1)=0.0)
   INTEGER(KIND=4),DIMENSION(:,:,:),  POINTER :: MRCHN   ! MAXLCH,MAXROD,NBANKS    REGION ASSIGNMENT FOR REGIONS IN THE IMMOVABLE PORTION OF THE CURRENT
!                   ROD CHANNEL, STARTING AT THE BOTTOM (Z=0.0) OF THE MODEL.
   INTEGER(KIND=4),DIMENSION(:,:,:),  POINTER :: MRROD   ! MAXLRD,MAXROD,NBANKS    REGION ASSIGNMENT FOR REGIONS IN THE MOVEABLE PORTION OF THE ROD,
!                   STARTING WITH THE REGION ADJACENT TO THE ROD TIP
   INTEGER(KIND=4),DIMENSION(:,:,:,:),POINTER :: MESH    ! 2,MAXMSH,MAXROD,NBANKS  1ST DIMENSION INDEX FOR PLANAR MESH CELL M IN THE CURRENT ROD CHANNEL
!                  2ND DIMENSION INDEX FOR PLANAR MESH CELL M IN THE CURRENT ROD CHANNEL
! CARD TYPE 9           BURNUP DEPENDENT CROSS SECTION SPECIFICATIONS (PRESENT IF NVARY .GT. 0)
!                    IF A PARTICULAR BINARY BIT IS 1, THE CORRESPONDING CROSS SECTION TYPE WILL BE BURNUP DEPENDENT.
!                       2**0 BIT, CAPTURE    2**1 BIT, FISSION
! THUS, IF KINDXS(L,1)=3, BOTH CAPTURE AND FISSION WILL BE BURNUP DEPENDENT
!          KINDXS(L,2)=0 IF NORMAL FITTING IS USED,
!          KINDXS(L,2)=1 IF FITTING IS DONE VS. THE NATURAL LOGARITHM OF THE ATOMIC DENSITIES
   REAL(KIND=8),DIMENSION(:),  POINTER :: BRNLAB  ! NVARY     LABELS OF BURNUP DEPENDENT ISOTOPES
   REAL(KIND=8),DIMENSION(:),  POINTER :: BRNREF  ! NVARY     LABELS OF THE REFERENCE BASE ISOTOPES FOR EACH OF THE BURNUP DEPENDENT ISOTOPES
   REAL(KIND=8),DIMENSION(:),  POINTER :: BRNMIN  ! NVARY     SMALLEST ATOMIC DENSITY USED FOR THE POLYNOMIAL FIT FOR THE L-TH BURNUP DEPENDENT ISOTOPE
   REAL(KIND=8),DIMENSION(:),  POINTER :: BRNMAX  ! NVARY     LARGEST ATOMIC DENSITY USED FOR THE POLYNOMIAL FIT FOR THE L-TH BURNUP DEPENDENT ISOTOPE
   INTEGER(KIND=4),DIMENSION(:),  POINTER :: NGPVAR  ! NVARY     # OF GROUPS THAT WILL HAVE BURNUP DEPENDENT CROSS SECTIONS FOR EACH OF THE BURNUP DEPENDENT ISOTOPE
   INTEGER(KIND=4),DIMENSION(:,:),POINTER :: KINDXS  ! NVARY,2   TYPE OF CROSS SECTIONS WHICH ARE BURNUP DEPENDENT.
!           THE BINARY BIT PATTERN OF THIS INTEGER(KIND=4) WORD SPECIFIES A LIST OF CROSS SECTION TYPES WHICH ARE BURNUP DEPENDENT.
! CARD TYPE 10   BURNUP DEPENDENT GROUPS (PRESENT IF MAXBRN .GT. 0)
!  NOBITC            0 IF THE 2**0 BIT IS 0 FOR ALL OF THE NVARY BURNUP DEPENDENT ISOTOPES IN THE KINDXS ARRAY (SEE THE 9D RECORD).  OTHERWISE, NOBITC=1.
!  NOBITF            0 IF THE 2**1 BIT IS 0 FOR ALL OF THE NVARY BURNUP DEPENDENT ISOTOPES IN THE KINDXS ARRAY (SEE THE 9D RECORD).  OTHERWISE, NOBITF=1.
!                    ONLY NGPVAR(L) VALUES OF I ARE PERTINENT FOR ISOTOPE L.
!                    NORCAP OR NORFIS WILL BE INCLUDED IF THE CORRESPONDING BIT IN THE KINDXS ARRAY (SEE THE 9D RECORD) IS 1 FOR ANY OF THE NVARY ISOTOPES.
!                    ELEMENTS OF THE NUMGRP, NORCAP, ARRAYS WHICH ARE NOT PERTINENT WILL BE 0.
   INTEGER(KIND=4),DIMENSION(:,:), POINTER :: NUMGRP  ! MAXBRN,NVARY   (I,L) GROUP # FOR THE I-TH GROUP THAT IS BURNUP DEPENDENT FOR THE L-TH BURNUP DEPENDENT ISOTOPE
   INTEGER(KIND=4),DIMENSION(:,:), POINTER :: NORCAP  ! MAXBRN,NVARY   (I,L) THE ORDER FOR THE LEAST SQUARES POLYNOMIAL FIT FOR CAPTURE FOR THE
!                      I-TH GROUP AND L-TH BURNUP DEPENDENT ISOTOPE
   INTEGER(KIND=4),DIMENSION(:,:), POINTER :: NORFIS  ! MAXBRN,NVARY   (I,L) THE ORDER FOR THE LEAST SQUARES POLYNOMIAL FIT FOR FISSION FOR THE
!                      I-TH GROUP AND L-TH BURNUP DEPENDENT ISOTOPE
! CARD TYPE 11   BURNUP DEPENDENT GROUPS (PRESENT IF MAXORD .GT. 0)
!  ONLY NORCAP(J,L)+1 VALUES OF I ARE PERTINENT FOR CFIT AND NORFIS(J,L)+1 VALUES OF I FOR FFIT.
! ALSO, ONLY NPGVAR(L) VALUES OF J ARE PERTINENT FOR ISOTOPE L.
! CFIT OR FFIT WILL BE INCLUDED IF THE CORRESPONDING BIT IN THE KINDXS ARRAY (SEE THE 9D RECORD) IS 1 FOR ANY OF THE NVARY ISOTOPES.
! ELEMENTS OF THE CFIT AND FFIT ARRAYS WHICH ARE NOT PERTINENT, WILL BE 0.
! THE COEFFICIENTS WILL BE USED IN A POLYNOMIAL EXPANSION IN THE ATOMIC DENSITY OF THE REFERENCE BASE ISOTOPE TO FORM A MULTIPLICATIVE FACTOR.
! FOR EXAMPLE, FOR CAPTURE   F=CFIT(1)+CFIT(2)*D+CFIT(3)*(D**2)+...  WHERE THE J AND L SUBSCRIPTS HAVE BEEN LEFT OFF AND D IS
!  THE ATOMIC DENSITY OF THE REFERENCE BASE ISOTOPE.
   REAL(KIND=8),DIMENSION(:,:,:),POINTER :: CFIT  ! MAXORD+1,MAXBRN,NVARY  (I,J,L) COEFFICIENTS IN THE POLYNOMIAL FIT FOR THE CAPTURE CROSS SECTION
   REAL(KIND=8),DIMENSION(:,:,:),POINTER :: FFIT  ! MAXORD+1,MAXBRN,NVARY  (I,J,L) COEFFICIENTS IN THE POLYNOMIAL FIT FOR THE FISSION CROSS SECTION
END TYPE

TYPE (LABELS_DATA), SAVE :: MODULE_LABELS ! A optional use "common block" data type for the module
INTEGER(KIND=4)            :: MODULE_OUT = 6               ! Module output unit

PRIVATE  MODULE_OUT

CONTAINS

!---------------------------------------------------------------------------------------------------------------------------------
!  LABELS_AssignPrintInfo(OUTPUT_UNIT)
!  Sets the output unit and debugprint level settings for the module
!---------------------------------------------------------------------------------------------------------------------------------
SUBROUTINE LABELS_AssignPrintInfo(MODULE_OUTPUT_UNIT)
INTEGER(KIND=4) MODULE_OUTPUT_UNIT    ! Reset the object output unit

MODULE_OUT = MODULE_OUTPUT_UNIT

END SUBROUTINE LABELS_AssignPrintInfo

!---------------------------------------------------------------------------------------------------------------------------------
!  LABELS_IdentifyZone(User_LABELS,User_ZoneName)
!  Searches through the list of zones and sub-zones to identify a given zone
!---------------------------------------------------------------------------------------------------------------------------------
INTEGER(KIND=4) FUNCTION LABELS_IdentifyZone(User_LABELS,User_ZoneName)
IMPLICIT NONE
! Passed in
TYPE (LABELS_DATA) User_LABELS  ! A user data variable to be Defined by WRITEing in a LABELS file
CHARACTER*8         User_ZoneName
! Local
INTEGER(KIND=4) I,J
J = 0
IF (User_LABELS%Defined) THEN
   DO I = 1,User_LABELS%NTZSZ
      IF (User_LABELS%CMPNAM(I) .EQ. User_ZoneName) THEN
         J = I
         EXIT
      END IF
   END DO
END IF
LABELS_IdentifyZone = J;

END FUNCTION LABELS_IdentifyZone

!---------------------------------------------------------------------------------------------------------------------------------
!  LABELS_IdentifyRegion(User_LABELS,User_RegionName)
!  Searches through the list of regions to identify a given region name
!---------------------------------------------------------------------------------------------------------------------------------
INTEGER(KIND=4) FUNCTION LABELS_IdentifyRegion(User_LABELS,User_RegionName)
IMPLICIT NONE
! Passed in
TYPE (LABELS_DATA) User_LABELS  ! A user data variable to be Defined by WRITEing in a LABELS file
CHARACTER*8         User_RegionName
! Local
INTEGER(KIND=4) I,J

J = 0
IF (User_LABELS%Defined) THEN
   DO I = 1,User_LABELS%NREG
      IF (User_LABELS%REGNAM(I) .EQ. User_RegionName) THEN
         J = I
         EXIT
      END IF
   END DO
END IF
LABELS_IdentifyRegion = J;

END FUNCTION LABELS_IdentifyRegion

!---------------------------------------------------------------------------------------------------------------------------------
!  LABELS_IdentifyArea(User_LABELS,User_AreaName)
!  Searches through the list of regions to identify a given area name
!---------------------------------------------------------------------------------------------------------------------------------
INTEGER(KIND=4) FUNCTION LABELS_IdentifyArea(User_LABELS,User_AreaName)
IMPLICIT NONE
! Passed in
TYPE (LABELS_DATA) User_LABELS  ! A user data variable to be Defined by WRITEing in a LABELS file
CHARACTER*8         User_AreaName
! Local
INTEGER(KIND=4) I,J

J = 0
IF (User_LABELS%Defined) THEN
   DO I = 1,User_LABELS%NAREA
      IF (User_LABELS%ARANAM(I) .EQ. User_AreaName) THEN
         J = I
         EXIT
      END IF
   END DO
END IF
LABELS_IdentifyArea = J;

END FUNCTION LABELS_IdentifyArea

!---------------------------------------------------------------------------------------------------------------------------------
!  LABELS_ApplyDIF3Dfix(User_LABELS)
!  Applies NE_Kind_DIF3DCharacterFix to all of the labels
!---------------------------------------------------------------------------------------------------------------------------------
!SUBROUTINE LABELS_ApplyDIF3Dfix(User_LABELS)
!USE NE_KIND
!IMPLICIT NONE
!! Passed in
!TYPE (LABELS_DATA) User_LABELS  ! A user data variable to be Defined by WRITEing in a LABELS file
!! Local
!INTEGER(KIND=4) I,J
!IF (User_LABELS%Defined) THEN
!   DO I = 1,User_LABELS%NTZSZ
!      CALL NE_Kind_DIF3DCharacterFix(User_LABELS%CMPNAM(I))
!   END DO
!   DO I = 1,User_LABELS%NREG
!      CALL NE_Kind_DIF3DCharacterFix(User_LABELS%REGNAM(I))
!   END DO
!   DO I = 1,User_LABELS%NAREA
!      CALL NE_Kind_DIF3DCharacterFix(User_LABELS%ARANAM(I))
!   END DO
!END IF
!END SUBROUTINE LABELS_ApplyDIF3Dfix


!---------------------------------------------------------------------------------------------------------------------------------
!  LABELS_PRINT(User_LABELS)
!  Prints the LABELS data
!---------------------------------------------------------------------------------------------------------------------------------
SUBROUTINE LABELS_PRINT(User_LABELS)
IMPLICIT NONE
! Passed in
TYPE (LABELS_DATA) User_LABELS  ! A user data variable to be Defined by WRITEing in a LABELS file
! Local
INTEGER(KIND=4) IOS,I,J,K,L,M,N

100 FORMAT('[LABELS]...SORRY, BUT I MUST STOP')
101 FORMAT('[LABELS]',107('.'))
102 FORMAT('')
105 FORMAT('[LABELS]...THERE WAS A NON-FATAL ERROR THAT OCCURED IN (PRINT)',53('.'))

IF (.NOT. User_LABELS%Defined) THEN  ! Data to write doesn't exist
   WRITE(MODULE_OUT,105)
   WRITE(MODULE_OUT,'("[LABELS]...USER DATA WAS UNDefined FOR PRINT <",A60,">",8("."))') User_LABELS%FILENAME
   WRITE(MODULE_OUT,100)
ELSE
   WRITE(MODULE_OUT,'("[LABELS]...NUMBER OF ZONES AND SUBZONES...........................",33("."),I16)') User_LABELS%NTZSZ
   WRITE(MODULE_OUT,'("[LABELS]...NUMBER OF REGIONS......................................",33("."),I16)') User_LABELS%NREG 
   WRITE(MODULE_OUT,'("[LABELS]...NUMBER OF AREAS........................................",33("."),I16)') User_LABELS%NAREA
   WRITE(MODULE_OUT,'("[LABELS]...LENGTH OF NRA ARRAY....................................",33("."),I16)') User_LABELS%LREGA
   WRITE(MODULE_OUT,'("[LABELS]...NUMBER OF HALF-HEIGHT AND EXTPOL. DIST. SPECS D=1......",33("."),I16)') User_LABELS%NHTS1
   WRITE(MODULE_OUT,'("[LABELS]...NUMBER OF HALF-HEIGHT AND EXTPOL. DIST. SPECS D=2......",33("."),I16)') User_LABELS%NHTS2
   WRITE(MODULE_OUT,'("[LABELS]...NUMBER OF NUCLIDE SETS.................................",33("."),I16)') User_LABELS%NSETS
   WRITE(MODULE_OUT,'("[LABELS]...LENGTH OF ALIAS ARRAY..................................",33("."),I16)') User_LABELS%NALIAS
   WRITE(MODULE_OUT,'("[LABELS]...NO. OF TRIANGLES PER HEX FOR TRIANGULAR GEOMETRIES.....",33("."),I16)') User_LABELS%NTRI  
   WRITE(MODULE_OUT,'("[LABELS]...MAX. NO. OF RINGS OF HEXAGONS FOR TRIANGULAR GEOMETRIES",33("."),I16)') User_LABELS%NRING 
   WRITE(MODULE_OUT,'("[LABELS]...NO. OF CONTROL-ROD CHANNELS IN THE MODEL...............",33("."),I16)') User_LABELS%NCHAN 
   WRITE(MODULE_OUT,'("[LABELS]...NO. OF CONTROL-ROD BANKS...............................",33("."),I16)') User_LABELS%NBANKS
   WRITE(MODULE_OUT,'("[LABELS]...ORIGINAL NO. OF FINE MESH INTERVALS IN AXIAL DIMENSION.",33("."),I16)') User_LABELS%LINTAX
   WRITE(MODULE_OUT,'("[LABELS]...MAXIMUM TIME...........................................",33("."),I16)') User_LABELS%MAXTIM
   WRITE(MODULE_OUT,'("[LABELS]...MAXIMUM NUMBER OF CONTROL RODS.........................",33("."),I16)') User_LABELS%MAXROD
   WRITE(MODULE_OUT,'("[LABELS]...MAXIMUM NUMBER OF MESHES...............................",33("."),I16)') User_LABELS%MAXMSH
   WRITE(MODULE_OUT,'("[LABELS]...MAXIMUM NUMBER OF CONTROL ROD PIECES...................",33("."),I16)') User_LABELS%MAXLRD
   WRITE(MODULE_OUT,'("[LABELS]...MAXIMUM NUMBER OF CONTROL ROD CHANNELS?................",33("."),I16)') User_LABELS%MAXLCH
   WRITE(MODULE_OUT,'("[LABELS]...NUMBER OF BURNUP DEPENDENT ISOTOPES....................",33("."),I16)') User_LABELS%NVARY
   WRITE(MODULE_OUT,'("[LABELS]...MAXIMUM NUMBER OF BURNUP DEPENDENT GROUPS..............",33("."),I16)') User_LABELS%MAXBRN
   WRITE(MODULE_OUT,'("[LABELS]...HIGHEST ORDER POLYNOMIAL FIT...........................",33("."),I16)') User_LABELS%MAXORD
   WRITE(MODULE_OUT,'("[LABELS]...DIMENSIONS? 1 OR 2.....................................",33("."),I16)') User_LABELS%ND

! Card type 2
   300 FORMAT(('[LABELS]...',7('[',I5,',',A8,']')     ))  ! CHARACTER
   305 FORMAT(('[LABELS]...',5('[',I5,',',1PE13.6,']')))  ! REAL
   310 FORMAT(('[LABELS]...',8('[',I5,',',I6,']')     ))  ! INTEGER(KIND=4)

   WRITE(MODULE_OUT,'("[LABELS]...COMPOSITION NAMES........................")')
   WRITE(MODULE_OUT,300) (I,User_LABELS%CMPNAM(I),I=1,User_LABELS%NTZSZ)
   WRITE(MODULE_OUT,'("[LABELS]...REGION NAMES.............................")')
   WRITE(MODULE_OUT,300) (I,User_LABELS%REGNAM(I),I=1,User_LABELS%NREG)
   WRITE(MODULE_OUT,'("[LABELS]...AREA NAMES...............................")')
   WRITE(MODULE_OUT,300) (I,User_LABELS%ARANAM(I),I=1,User_LABELS%NAREA)
   K = 1
   DO I = 1,User_LABELS%NAREA
      WRITE(MODULE_OUT,'("[LABELS]...REGIONS FOR AREA.........................",47("."),I16)') I
      WRITE(MODULE_OUT,300) (J,User_LABELS%REGNAM(User_LABELS%NRA(K+J)),J=1,User_LABELS%NRA(K))
      K = K + User_LABELS%NRA(K) + 1
   END DO

! WRITE Card Type 3
IF ((User_LABELS%NHTS1.GT.0) .OR. (User_LABELS%NHTS2.GT.0)) THEN
      315 FORMAT(('[LABELS]...',3('[',I3,',',1PE13.6,',',1PE13.6,']'),5(".")))
      WRITE(MODULE_OUT,'("[LABELS]...TRANSVERSE HALF HEIGHT AND EXTRAPOLATION PER REGION FOR FIRST DIMENSION",33("."))')
      WRITE(MODULE_OUT,315) (I,User_LABELS%HAFHT1(I),User_LABELS%XTRAP1(I),I=1,User_LABELS%NHTS1)
      WRITE(MODULE_OUT,'("[LABELS]...TRANSVERSE HALF HEIGHT AND EXTRAPOLATION PER REGION FOR SECOND DIMENSION",32("."))')
      WRITE(MODULE_OUT,315) (I,User_LABELS%HAFHT2(I),User_LABELS%XTRAP2(I),I=1,User_LABELS%NHTS2)
END IF

! WRITE Card Type 4
IF (User_LABELS%NSETS .GT. 0) THEN
      WRITE(MODULE_OUT,'("[LABELS]...NUCLIDE SET LABELS.....................",65("."))')
      WRITE(MODULE_OUT,300) (I,User_LABELS%SETISO(I),I=1,User_LABELS%NSETS)
END IF

! WRITE Card Type 5
IF (User_LABELS%NALIAS .GT. 0) THEN
      WRITE(MODULE_OUT,'("[LABELS]...ALIAS ZONE LABELS......................",65("."))')
      WRITE(MODULE_OUT,300) (I,User_LABELS%ALIAS(I),I=1,User_LABELS%NALIAS)
END IF

! WRITE Card Type 6   MULT=2   LINTAX*(MULT+1)-1+(2*MULT+2)*NBANKS
IF (User_LABELS%NBANKS .GT. 0) THEN
      WRITE(MODULE_OUT,'("[LABELS]...CONTROL ROD BANK LABEL........................................",42("."))')
      WRITE(MODULE_OUT,300) (I,User_LABELS%BNKLAB(I),I=1,User_LABELS%NBANKS)
      WRITE(MODULE_OUT,'("[LABELS]...ORIGINAL LAST-DIMENSION MESH STRUCTURE (CM)...................",42("."))')
      WRITE(MODULE_OUT,305) (I,User_LABELS%ZMESHO(I),I=1,User_LABELS%LINTAX)
      WRITE(MODULE_OUT,'("[LABELS]...CURRENT POSITION OF ROD BANK I (CM)...........................",42("."))')
      WRITE(MODULE_OUT,305) (I,User_LABELS%POSBNK(I),I=1,User_LABELS%NBANKS)
      WRITE(MODULE_OUT,'("[LABELS]...NO. OF RODS IN BANK I.........................................",42("."))')
      WRITE(MODULE_OUT,310) (I,User_LABELS%NRODS(I),I=1,User_LABELS%NBANKS)
      WRITE(MODULE_OUT,'("[LABELS]...NO. OF TIME NODES IN POSITION VS. TIME TABLE FOR BANK I.......",42("."))')
      WRITE(MODULE_OUT,310) (I,User_LABELS%NTIMES(I),I=1,User_LABELS%NBANKS)
      WRITE(MODULE_OUT,'("[LABELS]...ORIGINAL NUMBER OF FINE MESH BETWEEN ZMESHO(I) AND ZMESHO(I+1)",42("."))')
      WRITE(MODULE_OUT,310) (I,User_LABELS%KFINTO(I),I=1,User_LABELS%LINTAX-1)
! Card type 8 is a subWRITE for type 7
   DO I = 1,User_LABELS%NBANKS
! WRITE Card Type 7
         WRITE(MODULE_OUT,'("[LABELS]...TIME ENTRIES IN ROD POSITION VS. TIME TABLE FOR ROD BANK",32("."),I16)') I
         WRITE(MODULE_OUT,305) (J,User_LABELS%RBTIME(J,I),J=1,User_LABELS%NTIMES(I))
         WRITE(MODULE_OUT,'("[LABELS]...ROD-BANK POSITIONS IN TABLE (CM) FOR ROD BANK...........",32("."),I16)') I
         WRITE(MODULE_OUT,305) (J,User_LABELS%RBPOS(J,I),J=1,User_LABELS%NTIMES(I))
         WRITE(MODULE_OUT,'("[LABELS]...NO. OF PLANAR MESH CELLS IN ROD K OF CURRENT ROD BANK FOR ROD BANK",22("."),I16)') I
         WRITE(MODULE_OUT,310) (K,User_LABELS%NMESH(K,I),K=1,User_LABELS%NRODS(I))
         WRITE(MODULE_OUT,400) I
         400 FORMAT('[LABELS]...NO. OF REGIONS Defined FOR THE IMMOVABLE PORTION OF ROD CHANNEL K FOR ROD BANK',10('.'),I16)
         WRITE(MODULE_OUT,310) (K,User_LABELS%LENCHN(K,I),K=1,User_LABELS%NRODS(I))
         WRITE(MODULE_OUT,405) I
         405 FORMAT('[LABELS]...NO. OF REGIONS Defined FOR THE MOVEABLE PORTION OF ROD CHANNEL K FOR ROD BANK',11('.'),I16)
         WRITE(MODULE_OUT,310) (K,User_LABELS%LENROD(K,I),K=1,User_LABELS%NRODS(I))
      DO K = 1,User_LABELS%NRODS(I)
         IF (User_LABELS%LENCHN(K,I) + User_LABELS%LENROD(K,I) + User_LABELS%NMESH(K,I) .GT. 0) THEN
! WRITE Card Type 8  MULT=2   (MULT+1)*(LENROD(K)+LENCHN(K))+ND*NMESH(K)
               WRITE(MODULE_OUT,'("[LABELS]...LOW BOUND POS IMMOVABLE PORTION FOR ROD ",I3," IN BANK ",36("."),I16)') I,K
               WRITE(MODULE_OUT,305) (L,User_LABELS%POSCHN(L,K,I),L=1,User_LABELS%LENCHN(K,I))
               WRITE(MODULE_OUT,'("[LABELS]...LOW BOUND POS MOVABLE PORTION FOR ROD ",I3," IN BANK ",38("."),I16)') I,K
               WRITE(MODULE_OUT,305) (L,User_LABELS%POSROD(L,K,I),L=1,User_LABELS%LENROD(K,I))
               WRITE(MODULE_OUT,410) I,K
               410 FORMAT('[LABELS]...REGION ASSIGNMENT IN THE IMMOVABLE PORTION FOR ROD ',I3,' IN BANK ',25('.'),I16)
               WRITE(MODULE_OUT,310) (L,User_LABELS%MRCHN(L,K,I),L=1,User_LABELS%LENCHN(K,I))
               WRITE(MODULE_OUT,415) I,K
               415 FORMAT('[LABELS]...REGION ASSIGNMENT IN THE MOVEABLE PORTION FOR TIP OF ROD ',I3,' IN BANK ',19('.'),I16)
               WRITE(MODULE_OUT,310) (L,User_LABELS%MRROD(L,K,I),L=1,User_LABELS%LENROD(K,I))
               WRITE(MODULE_OUT,420)I,K
               420 FORMAT('[LABELS]...PLANAR MESH CELL FOR ROD ',I3,' IN BANK ',51('.'),I16)
               DO M=1,User_LABELS%NMESH(K,I)
                  WRITE(MODULE_OUT,425) (M,L,User_LABELS%MESH(L,M,K,I),L=1,User_LABELS%ND)
                  425 FORMAT(('[LABELS]...',6('[',I3,',',I3,',',I6,']')))     ! REAL
               END DO
         END IF ! CARD TYPE 8
      END DO  ! K=1,LRODS
   END DO !I = 1,NBANKS
END IF

IF (User_LABELS%NVARY .GT. 0) THEN
   WRITE(MODULE_OUT,'("[LABELS]...NVARY OPTION OF LABELS IS NOT SUPPORTED WELL",60("."))')
   WRITE(MODULE_OUT,'("[LABELS]...BASICALLY, IF THIS WORKS THEN YEAH, IF NOT THEN OH WELL",49("."))')
! Welcome to my nightmare.
! Basically the control characters are very confusing and I am just WRITEing data just like the specified format
! It shouldn't work since MAXBRN should not be the total number of points on type 10 or 11
! WRITE Card Type 9
      WRITE(MODULE_OUT,'("[LABELS]...LABELS OF BURNUP DEPENDENT ISOTOPES",69("."))')
      WRITE(MODULE_OUT,300) (L,User_LABELS%BRNLAB(L),L=1,User_LABELS%NVARY)
      WRITE(MODULE_OUT,'("[LABELS]...LABELS OF THE REFERENCE BASE ISOTOPES FOR EACH OF THE BURNUP DEPENDENT ISOTOPES",25("."))')
      WRITE(MODULE_OUT,305) (L,User_LABELS%BRNREF(L),L=1,User_LABELS%NVARY)
      WRITE(MODULE_OUT,'("[LABELS]...SMALLEST ATM DENS USED FOR THE POLY FIT FOR THE L-TH BURNUP DEPENDENT ISOTOPE",27("."))')
      WRITE(MODULE_OUT,305) (L,User_LABELS%BRNMIN(L),L=1,User_LABELS%NVARY)
      WRITE(MODULE_OUT,'("[LABELS]...LARGEST ATM DENS USED FOR THE POLY FIT FOR THE L-TH BURNUP DEPENDENT ISOTOPE",28("."))')
      WRITE(MODULE_OUT,305) (L,User_LABELS%BRNMAX(L),L=1,User_LABELS%NVARY)
      WRITE(MODULE_OUT,'("[LABELS]...THE # OF GROUPS THAT WILL HAVE BURNUP DEPENDENT XSECT FOR EACH ISOTOPE",34("."))')
      WRITE(MODULE_OUT,310) (L,User_LABELS%NGPVAR(L),L=1,User_LABELS%NVARY)
      WRITE(MODULE_OUT,'("[LABELS]...TYPE OF CROSS SECTIONS WHICH ARE BURNUP DEPENDENT",55("."))')
      WRITE(MODULE_OUT,310) (J,L,(User_LABELS%KINDXS(L,J),L=1,User_LABELS%NVARY),J=1,2)

   IF (User_LABELS%MAXBRN .GT. 0) THEN
! WRITE Card Type 10
         DO L = 1,User_LABELS%NVARY
            WRITE(MODULE_OUT,'("[LABELS]...GROUP # FOR THE I-TH GROUP FOR THE BURNUP DEPENDENT ISOTOPE",29("."),I16)') L
            WRITE(MODULE_OUT,310) (I,User_LABELS%NUMGRP(I,L),I=1,User_LABELS%MAXBRN)
            WRITE(MODULE_OUT,'("[LABELS]...THE CAPTURE POLY FIT ORDER FOR THE BURNUP DEPENDENT ISOTOPE",29("."),I16)') L
            WRITE(MODULE_OUT,305) (I,User_LABELS%NORCAP(I,L),I=1,User_LABELS%MAXBRN)
            WRITE(MODULE_OUT,'("[LABELS]...THE FISSION POLY FIT ORDER FOR THE BURNUP DEPENDENT ISOTOPE",29("."),I16)') L
            WRITE(MODULE_OUT,305) (I,User_LABELS%NORFIS(I,L),I=1,User_LABELS%MAXBRN)
          END DO
! WRITE Card Type 11
      IF (User_LABELS%MAXORD .GT. 0) THEN
            DO L = 1,User_LABELS%NVARY
               DO M = 1,User_LABELS%MAXBRN
                  WRITE(MODULE_OUT,'("[LABELS]...CAPTURE COEFFICIENTS FOR THE BURNUP GROUP ",I5," ISOTOPE",33("."),I16)') M,L
                  WRITE(MODULE_OUT,305) (I,User_LABELS%CFIT(I,M,L),I=1,User_LABELS%MAXORD+1)
                  WRITE(MODULE_OUT,'("[LABELS]...FISSION COEFFICIENTS FOR THE BURNUP GROUP ",I5," ISOTOPE",33("."),I16)') M,L
                  WRITE(MODULE_OUT,305) (I,User_LABELS%FFIT(I,M,L),I=1,User_LABELS%MAXORD+1)
               END DO
            END DO
      END IF ! MAXORD .GT. 0
   END IF ! MAXBURN .GT. 0
END IF ! NVARY .GT. 0

END IF ! IF Defined

END SUBROUTINE LABELS_PRINT

!---------------------------------------------------------------------------------------------------------------------------------
!  LABELS_Copy(Source_LABELS,Dest_LABELS)
!  Copies the data structure
!---------------------------------------------------------------------------------------------------------------------------------
SUBROUTINE LABELS_Copy(Source_LABELS,Dest_LABELS)
IMPLICIT NONE
! Passed in
TYPE (LABELS_DATA) Source_LABELS,Dest_LABELS
! Local variables
INTEGER(KIND=4) :: NTZSZ    ! NUMBER OF ZONES AND SUBZONES
INTEGER(KIND=4) :: NREG     ! NUMBER OF REGIONS
INTEGER(KIND=4) :: NAREA    ! NUMBER OF AREAS
INTEGER(KIND=4) :: LREGA    ! LENGTH OF NRA ARRAY
INTEGER(KIND=4) :: NHTS1    ! NUMBER OF HALF-HEIGHT AND EXTRAPOLATION DISTANCE SPECIFICATIONS {0 - NONE,1 - SINGLE VALUE USED EVERYWHERE, .EQ.NREG - REGION DEPENDENT)
INTEGER(KIND=4) :: NHTS2    ! NUMBER OF HALF-HEIGHT AND EXTRAPOLATION DISTANCE SPECIFICATIONS FOR THE SECOND DIRECTION. {SAME DEFINITION AS NHTS1}
INTEGER(KIND=4) :: NSETS    ! NUMBER OF NUCLIDE SETS
INTEGER(KIND=4) :: NALIAS   ! 0 IF RECORD 5D IS NOT PRESENT.  IF GREATER THAN 0, RECORD 5D IS PRESENT AND THE ALIAS ARRAY IS OF LENGTH NALIAS.
INTEGER(KIND=4) :: NTRI     ! NO. OF TRIANGLES PER HEX FOR TRIANGULAR GEOMETRIES
INTEGER(KIND=4) :: NRING    ! MAX. NO. OF RINGS OF HEXAGONS FOR TRIANGULAR GEOMETRIES
INTEGER(KIND=4) :: NCHAN    ! NO. OF CONTROL-ROD CHANNELS IN THE MODEL.  NCHAN IS THE SUM OF NRODS (RECORD 6D) OVER ALL CONTROL ROD BANKS.
INTEGER(KIND=4) :: NBANKS   ! NO. OF CONTROL-ROD BANKS
INTEGER(KIND=4) :: LINTAX   ! ORIGINAL NO. OF FINE MESH INTERVALS IN AXIAL DIMENSION
INTEGER(KIND=4) :: MAXTIM   ! MAXIMUM VALUE OF NTIMES(I) (I=1,NBANKS)
INTEGER(KIND=4) :: MAXROD   ! MAXIMUM VALUE OF NRODS(I) (I=1,NBANKS)
INTEGER(KIND=4) :: MAXMSH   ! MAXIMUM VALUE OF NMESH(K) (K=1,LRODS;I=1,NBANKS) WHERE LRODS=NRODS(I)
INTEGER(KIND=4) :: MAXLRD   ! MAXIMUM VALUE OF LENROD(K) (K=1,LRODS;I=1,NBANKS)
INTEGER(KIND=4) :: MAXLCH   ! MAXIMUM VALUE OF LENCHN(K) (K=1,LRODS;I=1,NBANKS)
INTEGER(KIND=4) :: NVARY    ! NUMBER OF BURNUP DEPENDENT ISOTOPES
INTEGER(KIND=4) :: MAXBRN   ! THE MAXIMUM NUMBER OF GROUPS THAT ARE BURNUP DEPENDENT FOR ANY OF THE BURNUP DEPENDENT ISOTOPES
INTEGER(KIND=4) :: MAXORD   ! THE HIGHEST ORDER POLYNOMIAL FIT FOR ANY OF THE GROUPS FOR ANY OF THE BURNABLE ISOTOPES
INTEGER(KIND=4) :: ND       ! 1 IN XY AND RZ GEOMETRIES, 2 IN XYZ, R-THETA-Z, THETA-R-Z, HEX-Z, AND TRIANGULAR-Z MODELS

CALL LABELS_Void(Dest_LABELS)

IF (Source_LABELS%Defined) THEN
   NTZSZ  = Source_LABELS%NTZSZ 
   NREG   = Source_LABELS%NREG  
   NAREA  = Source_LABELS%NAREA 
   LREGA  = Source_LABELS%LREGA 
   NHTS1  = Source_LABELS%NHTS1 
   NHTS2  = Source_LABELS%NHTS2 
   NSETS  = Source_LABELS%NSETS 
   NALIAS = Source_LABELS%NALIAS
   NTRI   = Source_LABELS%NTRI  
   NRING  = Source_LABELS%NRING 
   NCHAN  = Source_LABELS%NCHAN 
   NBANKS = Source_LABELS%NBANKS
   LINTAX = Source_LABELS%LINTAX
   MAXTIM = Source_LABELS%MAXTIM
   MAXROD = Source_LABELS%MAXROD
   MAXMSH = Source_LABELS%MAXMSH
   MAXLRD = Source_LABELS%MAXLRD
   MAXLCH = Source_LABELS%MAXLCH
   NVARY  = Source_LABELS%NVARY 
   MAXBRN = Source_LABELS%MAXBRN
   MAXORD = Source_LABELS%MAXORD
   ND     = Source_LABELS%ND
   CALL LABELS_Define(Dest_LABELS,NTZSZ,NREG,NAREA,LREGA,NHTS1,NHTS2,NSETS,NALIAS,NTRI,NRING,NCHAN,  &
                   NBANKS,LINTAX,MAXTIM,MAXROD,MAXMSH,MAXLRD,MAXLCH,NVARY,MAXBRN,MAXORD,ND)
   Dest_LABELS%CMPNAM = Source_LABELS%CMPNAM 
   Dest_LABELS%REGNAM = Source_LABELS%REGNAM 
   Dest_LABELS%ARANAM = Source_LABELS%ARANAM 
   Dest_LABELS%NRA    = Source_LABELS%NRA    
   Dest_LABELS%HAFHT1 = Source_LABELS%HAFHT1 
   Dest_LABELS%XTRAP1 = Source_LABELS%XTRAP1 
   Dest_LABELS%HAFHT2 = Source_LABELS%HAFHT2 
   Dest_LABELS%XTRAP2 = Source_LABELS%XTRAP2 
   Dest_LABELS%SETISO = Source_LABELS%SETISO 
   Dest_LABELS%ALIAS  = Source_LABELS%ALIAS  
   Dest_LABELS%BNKLAB = Source_LABELS%BNKLAB 
   Dest_LABELS%ZMESHO = Source_LABELS%ZMESHO 
   Dest_LABELS%POSBNK = Source_LABELS%POSBNK 
   Dest_LABELS%NRODS  = Source_LABELS%NRODS  
   Dest_LABELS%NTIMES = Source_LABELS%NTIMES 
   Dest_LABELS%KFINTO = Source_LABELS%KFINTO 
   Dest_LABELS%RBTIME = Source_LABELS%RBTIME 
   Dest_LABELS%RBPOS  = Source_LABELS%RBPOS  
   Dest_LABELS%NMESH  = Source_LABELS%NMESH  
   Dest_LABELS%LENCHN = Source_LABELS%LENCHN 
   Dest_LABELS%LENROD = Source_LABELS%LENROD 
   Dest_LABELS%POSCHN = Source_LABELS%POSCHN 
   Dest_LABELS%POSROD = Source_LABELS%POSROD 
   Dest_LABELS%MRCHN  = Source_LABELS%MRCHN  
   Dest_LABELS%MRROD  = Source_LABELS%MRROD  
   Dest_LABELS%MESH   = Source_LABELS%MESH   
   Dest_LABELS%BRNLAB = Source_LABELS%BRNLAB 
   Dest_LABELS%BRNREF = Source_LABELS%BRNREF 
   Dest_LABELS%BRNMIN = Source_LABELS%BRNMIN 
   Dest_LABELS%BRNMAX = Source_LABELS%BRNMAX 
   Dest_LABELS%NGPVAR = Source_LABELS%NGPVAR 
   Dest_LABELS%KINDXS = Source_LABELS%KINDXS 
   Dest_LABELS%NUMGRP = Source_LABELS%NUMGRP 
   Dest_LABELS%NORCAP = Source_LABELS%NORCAP 
   Dest_LABELS%NORFIS = Source_LABELS%NORFIS 
   Dest_LABELS%CFIT   = Source_LABELS%CFIT   
   Dest_LABELS%FFIT   = Source_LABELS%FFIT   
END IF

END SUBROUTINE LABELS_Copy

!---------------------------------------------------------------------------------------------------------------------------------
!  LABELS_Define(User_LABELS,NTZSZ,NREG,NAREA,LREGA,NHTS1,NHTS2,NSETS,NALIAS,NTRI,NRING,NCHAN,  &
!                       NBANKS,LINTAX,MAXTIM,MAXROD,MAXMSH,MAXLRD,MAXLCH,NVARY,MAXBRN,MAXORD,ND        )
!  Allocates and initializes the LABELS data structure
!---------------------------------------------------------------------------------------------------------------------------------
SUBROUTINE LABELS_Define(User_LABELS,NTZSZ,NREG,NAREA,LREGA,NHTS1,NHTS2,NSETS,NALIAS,NTRI,NRING,NCHAN,  &
                                NBANKS,LINTAX,MAXTIM,MAXROD,MAXMSH,MAXLRD,MAXLCH,NVARY,MAXBRN,MAXORD,ND        )
IMPLICIT NONE
! Passed in
TYPE (LABELS_DATA) User_LABELS  ! A user data variable to be Defined by reading in a LABELS file
INTEGER(KIND=4) :: NTZSZ    ! NUMBER OF ZONES AND SUBZONES
INTEGER(KIND=4) :: NREG     ! NUMBER OF REGIONS
INTEGER(KIND=4) :: NAREA    ! NUMBER OF AREAS
INTEGER(KIND=4) :: LREGA    ! LENGTH OF NRA ARRAY
INTEGER(KIND=4) :: NHTS1    ! NUMBER OF HALF-HEIGHT AND EXTRAPOLATION DISTANCE SPECIFICATIONS {0 - NONE,1 - SINGLE VALUE USED EVERYWHERE, .EQ.NREG - REGION DEPENDENT)
INTEGER(KIND=4) :: NHTS2    ! NUMBER OF HALF-HEIGHT AND EXTRAPOLATION DISTANCE SPECIFICATIONS FOR THE SECOND DIRECTION. {SAME DEFINITION AS NHTS1}
INTEGER(KIND=4) :: NSETS    ! NUMBER OF NUCLIDE SETS
INTEGER(KIND=4) :: NALIAS   ! 0 IF RECORD 5D IS NOT PRESENT.  IF GREATER THAN 0, RECORD 5D IS PRESENT AND THE ALIAS ARRAY IS OF LENGTH NALIAS.
INTEGER(KIND=4) :: NTRI     ! NO. OF TRIANGLES PER HEX FOR TRIANGULAR GEOMETRIES
INTEGER(KIND=4) :: NRING    ! MAX. NO. OF RINGS OF HEXAGONS FOR TRIANGULAR GEOMETRIES
INTEGER(KIND=4) :: NCHAN    ! NO. OF CONTROL-ROD CHANNELS IN THE MODEL.  NCHAN IS THE SUM OF NRODS (RECORD 6D) OVER ALL CONTROL ROD BANKS.
INTEGER(KIND=4) :: NBANKS   ! NO. OF CONTROL-ROD BANKS
INTEGER(KIND=4) :: LINTAX   ! ORIGINAL NO. OF FINE MESH INTERVALS IN AXIAL DIMENSION
INTEGER(KIND=4) :: MAXTIM   ! MAXIMUM VALUE OF NTIMES(I) (I=1,NBANKS)
INTEGER(KIND=4) :: MAXROD   ! MAXIMUM VALUE OF NRODS(I) (I=1,NBANKS)
INTEGER(KIND=4) :: MAXMSH   ! MAXIMUM VALUE OF NMESH(K) (K=1,LRODS;I=1,NBANKS) WHERE LRODS=NRODS(I)
INTEGER(KIND=4) :: MAXLRD   ! MAXIMUM VALUE OF LENROD(K) (K=1,LRODS;I=1,NBANKS)
INTEGER(KIND=4) :: MAXLCH   ! MAXIMUM VALUE OF LENCHN(K) (K=1,LRODS;I=1,NBANKS)
INTEGER(KIND=4) :: NVARY    ! NUMBER OF BURNUP DEPENDENT ISOTOPES
INTEGER(KIND=4) :: MAXBRN   ! THE MAXIMUM NUMBER OF GROUPS THAT ARE BURNUP DEPENDENT FOR ANY OF THE BURNUP DEPENDENT ISOTOPES
INTEGER(KIND=4) :: MAXORD   ! THE HIGHEST ORDER POLYNOMIAL FIT FOR ANY OF THE GROUPS FOR ANY OF THE BURNABLE ISOTOPES
INTEGER(KIND=4) :: ND       ! 1 IN XY AND RZ GEOMETRIES, 2 IN XYZ, R-THETA-Z, THETA-R-Z, HEX-Z, AND TRIANGULAR-Z MODELS
! Local
INTEGER(KIND=4) IOS

100 FORMAT('[LABELS]...SORRY, BUT I MUST STOP')
101 FORMAT('[LABELS]',107('.'))
102 FORMAT('')
105 FORMAT('[LABELS]...THERE WAS A FATAL ERROR THAT OCCURED IN (ALLOCATE)',54('.'))

IF (User_LABELS%Defined) CALL LABELS_Void(User_LABELS)   ! If the variable is already Defined, void it

# 610


IF (NTZSZ .LE. 0) THEN
   WRITE(MODULE_OUT,105)
   WRITE(MODULE_OUT,'("[LABELS]...INVALID NUMBER OF ZONES AND SUBZONES.............................(NTZSZ )",15("."),I16)') NTZSZ
   WRITE(MODULE_OUT,100)
   CALL Abort
END IF

IF (NREG .LE. 0) THEN
   WRITE(MODULE_OUT,105)
   WRITE(MODULE_OUT,'("[LABELS]...INVALID NUMBER OF REGIONS........................................(NREG  )",15("."),I16)') NREG 
   WRITE(MODULE_OUT,100)
   CALL Abort
END IF

IF (NAREA .LT. 0) THEN
   WRITE(MODULE_OUT,105)
   WRITE(MODULE_OUT,'("[LABELS]...INVALID NUMBER OF AREAS..........................................(NAREA )",15("."),I16)') NAREA
   WRITE(MODULE_OUT,100)
   CALL Abort
ELSE IF (NAREA .GT. 0) THEN
 IF (LREGA .LE. 0) THEN
   WRITE(MODULE_OUT,105)
   WRITE(MODULE_OUT,'("[LABELS]...INVALID LENGTH OF NRA ARRAY......................................(LREGA )",15("."),I16)') LREGA
   WRITE(MODULE_OUT,100)
   CALL Abort
 END IF
END IF

IF (NHTS1 .LT. 0) THEN
   WRITE(MODULE_OUT,105)
   WRITE(MODULE_OUT,'("[LABELS]...INVALID NUMBER OF HALF-HEIGHT AND EXTPOL. DIST. SPECS D=1........(NHTS1 )",15("."),I16)') NHTS1
   WRITE(MODULE_OUT,100)
   CALL Abort
END IF

IF (NHTS2 .LT. 0) THEN
   WRITE(MODULE_OUT,105)
   WRITE(MODULE_OUT,'("[LABELS]...INVALID NUMBER OF HALF-HEIGHT AND EXTPOL. DIST. SPECS D=2........(NHTS2 )",15("."),I16)') NHTS2
   WRITE(MODULE_OUT,100)
   CALL Abort
END IF

IF (NSETS .LT. 0) THEN
   WRITE(MODULE_OUT,105)
   WRITE(MODULE_OUT,'("[LABELS]...INVALID NUMBER OF NUCLIDE SETS...................................(NSETS )",15("."),I16)') NSETS
   WRITE(MODULE_OUT,100)
   CALL Abort
END IF

IF (NALIAS .LT. 0) THEN
   WRITE(MODULE_OUT,105)
   WRITE(MODULE_OUT,'("[LABELS]...INVALID LENGTH OF ALIAS ARRAY....................................(NALIAS)",15("."),I16)') NALIAS
   WRITE(MODULE_OUT,100)
   CALL Abort
END IF

IF (NTRI .LT. 0) THEN
   WRITE(MODULE_OUT,105)
   WRITE(MODULE_OUT,'("[LABELS]...INVALID NO. OF TRIANGLES PER HEX FOR TRIANGULAR GEOMETRIES.......(NTRI  )",15("."),I16)') NTRI  
   WRITE(MODULE_OUT,100)
   CALL Abort
END IF

IF (NRING .LT. 0) THEN
   WRITE(MODULE_OUT,105)
   WRITE(MODULE_OUT,'("[LABELS]...INVALID MAX. NO. OF RINGS OF HEXAGONS FOR TRIANGULAR GEOMETRIES..(NRING )",15("."),I16)') NRING 
   WRITE(MODULE_OUT,100)
   CALL Abort
END IF

IF (NBANKS .LT. 0) THEN
   WRITE(MODULE_OUT,105)
   WRITE(MODULE_OUT,'("[LABELS]...INVALID NO. OF CONTROL-ROD BANKS.................................(NBANKS)",15("."),I16)') NBANKS
   WRITE(MODULE_OUT,100)
   CALL Abort
ELSE IF (NBANKS .GT. 0) THEN
 IF (NCHAN .LE. 0) THEN
   WRITE(MODULE_OUT,105)
   WRITE(MODULE_OUT,'("[LABELS]...INVALID NO. OF CONTROL-ROD CHANNELS IN THE MODEL.................(NCHAN )",15("."),I16)') NCHAN 
   WRITE(MODULE_OUT,100)
   CALL Abort
 END IF
 IF (LINTAX .LE. 0) THEN
   WRITE(MODULE_OUT,105)
   WRITE(MODULE_OUT,'("[LABELS]...INVALID ORIGINAL NO. OF FINE MESH INTERVALS IN AXIAL DIMENSION...(LINTAX)",15("."),I16)') LINTAX
   WRITE(MODULE_OUT,100)
   CALL Abort
 END IF
 IF (MAXTIM .LE. 0) THEN
   WRITE(MODULE_OUT,105)
   WRITE(MODULE_OUT,'("[LABELS]...INVALID MAXIMUM TIME.............................................(MAXTIM)",15("."),I16)') MAXTIM
   WRITE(MODULE_OUT,100)
   CALL Abort
 END IF
 IF (MAXROD .LE. 0) THEN
   WRITE(MODULE_OUT,105)
   WRITE(MODULE_OUT,'("[LABELS]...INVALID MAXIMUM NUMBER OF CONTROL RODS...........................(MAXROD)",15("."),I16)') MAXROD
   WRITE(MODULE_OUT,100)
   CALL Abort
 END IF
 IF (MAXMSH .LE. 0) THEN
   WRITE(MODULE_OUT,105)
   WRITE(MODULE_OUT,'("[LABELS]...INVALID MAXIMUM NUMBER OF MESHES.................................(MAXMSH)",15("."),I16)') MAXMSH
   WRITE(MODULE_OUT,100)
   CALL Abort
 END IF
 IF (MAXLRD .LE. 0) THEN
   WRITE(MODULE_OUT,105)
   WRITE(MODULE_OUT,'("[LABELS]...INVALID MAXIMUM NUMBER OF CONTROL ROD PIECES.....................(MAXLRD)",15("."),I16)') MAXLRD
   WRITE(MODULE_OUT,100)
   CALL Abort
 END IF
 IF (MAXLCH .LE. 0) THEN
   WRITE(MODULE_OUT,105)
   WRITE(MODULE_OUT,'("[LABELS]...INVALID MAXIMUM NUMBER OF CONTROL ROD CHANNELS?..................(MAXLCH)",15("."),I16)') MAXLCH
   WRITE(MODULE_OUT,100)
   CALL Abort
 END IF
END IF

IF (NVARY .LT. 0) THEN
   WRITE(MODULE_OUT,105)
   WRITE(MODULE_OUT,'("[LABELS]...INVALID NUMBER OF BURNUP DEPENDENT ISOTOPES......................(NVARY )",15("."),I16)') NVARY
   WRITE(MODULE_OUT,100)
   CALL Abort
ELSE IF (NVARY .GT. 0) THEN
 IF (MAXBRN .LT. 0) THEN
   WRITE(MODULE_OUT,105)
   WRITE(MODULE_OUT,'("[LABELS]...INVALID MAXIMUM NUMBER OF BURNUP DEPENDENT GROUPS................(MAXBRN)",15("."),I16)') MAXBRN
   WRITE(MODULE_OUT,100)
   CALL Abort
 END IF
 IF (MAXBRN .LT. 0) THEN
   WRITE(MODULE_OUT,105)
   WRITE(MODULE_OUT,'("[LABELS]...INVALID HIGHEST ORDER POLYNOMIAL FIT.............................(MAXORD)",15("."),I16)') MAXORD
   WRITE(MODULE_OUT,100)
   CALL Abort
 END IF
 IF (MAXBRN .LT. 0) THEN
   WRITE(MODULE_OUT,105)
   WRITE(MODULE_OUT,'("[LABELS]...INVALID DIMENSIONS? 1 OR 2.......................................(ND    )",15("."),I16)') ND 
   WRITE(MODULE_OUT,100)
   CALL Abort
 END IF
END IF

! CARD TYPE 02
ALLOCATE(User_LABELS%CMPNAM(NTZSZ),User_LABELS%REGNAM(NREG),User_LABELS%ARANAM(NAREA),User_LABELS%NRA(LREGA),STAT=IOS)
IF (IOS .NE. 0) THEN
   WRITE(MODULE_OUT,105)
   WRITE(MODULE_OUT,'("[LABELS]...FAILED TO ALLOCATE LABELS DATA FOR CARD TYPE 02",57("."))')
   WRITE(MODULE_OUT,'("[LABELS]...NUMBER OF ZONES AND SUBZONES.............................(NTZSZ )",23("."),I16)') NTZSZ
   WRITE(MODULE_OUT,'("[LABELS]...NUMBER OF REGIONS........................................(NREG  )",23("."),I16)') NREG 
   WRITE(MODULE_OUT,'("[LABELS]...NUMBER OF AREAS..........................................(NAREA )",23("."),I16)') NAREA
   WRITE(MODULE_OUT,'("[LABELS]...LENGTH OF NRA ARRAY......................................(LREGA )",23("."),I16)') LREGA
   WRITE(MODULE_OUT,100)
   CALL Abort
END IF
User_LABELS%CMPNAM = 'UNDEFINE'
User_LABELS%REGNAM = 'UNDEFINE'
IF (NAREA .GT. 0) THEN
   User_LABELS%ARANAM = 'UNDEFINE'
   User_LABELS%NRA = 0
END IF

! CARD TYPE 03
IF ((NHTS1 .GT. 0) .OR. (NHTS2 .GT. 0)) THEN
   ALLOCATE(User_LABELS%HAFHT1(NHTS1),User_LABELS%XTRAP1(NHTS1),User_LABELS%HAFHT2(NHTS2),User_LABELS%XTRAP2(NHTS2),STAT=IOS)
ELSE
   ALLOCATE(User_LABELS%HAFHT1(1),User_LABELS%XTRAP1(1),User_LABELS%HAFHT2(1),User_LABELS%XTRAP2(1),STAT=IOS)
END IF
IF (IOS .NE. 0) THEN
  WRITE(MODULE_OUT,105)
  WRITE(MODULE_OUT,'("[LABELS]...FAILED TO ALLOCATE LABELS DATA FOR CARD TYPE 03",57("."))')
  WRITE(MODULE_OUT,'("[LABELS]...NUMBER OF HALF-HEIGHT AND EXTPOL. DIST. SPECS D=1........(NHTS1 )",23("."),I16)') NHTS1
  WRITE(MODULE_OUT,'("[LABELS]...NUMBER OF HALF-HEIGHT AND EXTPOL. DIST. SPECS D=2........(NHTS2 )",23("."),I16)') NHTS2
  WRITE(MODULE_OUT,100)
  CALL Abort
END IF
IF (NHTS1 .GT. 0) THEN
   User_LABELS%HAFHT1 = 0.0
   User_LABELS%XTRAP1 = 0.0
END IF
IF (NHTS1 .GT. 0) THEN
   User_LABELS%HAFHT2 = 0.0
   User_LABELS%XTRAP2 = 0.0
END IF 

! CARD TYPE 04
IF (NSETS .GT. 0) THEN
   ALLOCATE(User_LABELS%SETISO(NSETS),STAT=IOS)
ELSE
   ALLOCATE(User_LABELS%SETISO(1),STAT=IOS)
END IF
IF (IOS .NE. 0) THEN
  WRITE(MODULE_OUT,105)
  WRITE(MODULE_OUT,'("[LABELS]...FAILED TO ALLOCATE LABELS DATA FOR CARD TYPE 04",57("."))')
  WRITE(MODULE_OUT,'("[LABELS]...NUMBER OF NUCLIDE SETS...................................(NSETS )",23("."),I16)') NSETS
  WRITE(MODULE_OUT,100)
  CALL Abort
END IF
User_LABELS%SETISO = 'UNDEFINE'

! CARD TYPE 05
IF (NALIAS .GT. 0) THEN
   ALLOCATE(User_LABELS%ALIAS(NALIAS),STAT=IOS)
ELSE
   ALLOCATE(User_LABELS%ALIAS(1),STAT=IOS)
END IF
IF (IOS .NE. 0) THEN
  WRITE(MODULE_OUT,105)
  WRITE(MODULE_OUT,'("[LABELS]...FAILED TO ALLOCATE LABELS DATA FOR CARD TYPE 05",57("."))')
  WRITE(MODULE_OUT,'("[LABELS]...LENGTH OF ALIAS ARRAY....................................(NALIAS)",23("."),I16)') NALIAS
  WRITE(MODULE_OUT,100)
  CALL Abort
END IF
User_LABELS%ALIAS = 'UNDEFINE'

! CARD TYPE 06-08
IF (NBANKS .GT. 0) THEN
 ALLOCATE(User_LABELS%BNKLAB(NBANKS),User_LABELS%ZMESHO(LINTAX),User_LABELS%POSBNK(NBANKS),User_LABELS%NRODS(NBANKS), & ! 6
          User_LABELS%NTIMES(NBANKS),User_LABELS%KFINTO(LINTAX-1), &
          User_LABELS%RBTIME(MAXTIM,NBANKS),User_LABELS%RBPOS(MAXTIM,NBANKS),User_LABELS%NMESH(MAXROD,NBANKS), &  ! 7
          User_LABELS%LENCHN(MAXROD,NBANKS),User_LABELS%LENROD(MAXROD,NBANKS),&
          User_LABELS%POSCHN(MAXLCH,MAXROD,NBANKS),User_LABELS%POSROD(MAXLRD,MAXROD,NBANKS),          &  ! 8
          User_LABELS%MRCHN(MAXLCH,MAXROD,NBANKS),                                                    &
          User_LABELS%MRROD(MAXLRD,MAXROD,NBANKS),User_LABELS%MESH(2,MAXMSH,MAXROD,NBANKS),STAT=IOS   )
ELSE
 ALLOCATE(User_LABELS%BNKLAB(1),User_LABELS%ZMESHO(1),User_LABELS%POSBNK(1),User_LABELS%NRODS(1), & ! 6
          User_LABELS%NTIMES(1),User_LABELS%KFINTO(1), &
          User_LABELS%RBTIME(1,1),User_LABELS%RBPOS(1,1),User_LABELS%NMESH(1,1), &  ! 7
          User_LABELS%LENCHN(1,1),User_LABELS%LENROD(1,1),&
          User_LABELS%POSCHN(1,1,1),User_LABELS%POSROD(1,1,1),          &  ! 8
          User_LABELS%MRCHN(1,1,1),                                                    &
          User_LABELS%MRROD(1,1,1),User_LABELS%MESH(1,1,1,1),STAT=IOS   )
END IF
IF (IOS .NE. 0) THEN
  WRITE(MODULE_OUT,105)
  WRITE(MODULE_OUT,'("[LABELS]...FAILED TO ALLOCATE LABELS DATA FOR CARD TYPE 06-08",57("."))')
  WRITE(MODULE_OUT,'("[LABELS]...NO. OF CONTROL-ROD CHANNELS IN THE MODEL.................(NCHAN )",23("."),I16)') NCHAN 
  WRITE(MODULE_OUT,'("[LABELS]...NO. OF CONTROL-ROD BANKS.................................(NBANKS)",23("."),I16)') NBANKS
  WRITE(MODULE_OUT,'("[LABELS]...ORIGINAL NO. OF FINE MESH INTERVALS IN AXIAL DIMENSION...(LINTAX)",23("."),I16)') LINTAX
  WRITE(MODULE_OUT,'("[LABELS]...NO. OF CONTROL-ROD BANKS.................................(NBANKS)",23("."),I16)') NBANKS
  WRITE(MODULE_OUT,'("[LABELS]...MAXIMUM TIME.............................................(MAXTIM)",23("."),I16)') MAXTIM
  WRITE(MODULE_OUT,'("[LABELS]...NO. OF CONTROL-ROD BANKS.................................(NBANKS)",23("."),I16)') NBANKS
  WRITE(MODULE_OUT,'("[LABELS]...MAXIMUM NUMBER OF CONTROL RODS...........................(MAXROD)",23("."),I16)') MAXROD
  WRITE(MODULE_OUT,'("[LABELS]...MAXIMUM NUMBER OF CONTROL ROD CHANNELS?..................(MAXLCH)",23("."),I16)') MAXLCH
  WRITE(MODULE_OUT,'("[LABELS]...MAXIMUM NUMBER OF MESHES.................................(MAXMSH)",23("."),I16)') MAXMSH
  WRITE(MODULE_OUT,100)
  CALL Abort
END IF
User_LABELS%BNKLAB = 'UNDEFINE'
User_LABELS%ZMESHO = 0.0
User_LABELS%POSBNK = 0.0
User_LABELS%NRODS  = 0
User_LABELS%NTIMES = 0
User_LABELS%KFINTO = 0
User_LABELS%RBTIME = 0.0
User_LABELS%RBPOS  = 0.0
User_LABELS%NMESH  = 0
User_LABELS%LENCHN = 0
User_LABELS%LENROD = 0
User_LABELS%POSCHN = 0.0
User_LABELS%POSROD = 0.0
User_LABELS%MRCHN  = 0
User_LABELS%MRROD  = 0
User_LABELS%MESH   = 0

! CARD TYPE 09,10,11
IF (NVARY .GT. 0) THEN
 ALLOCATE(User_LABELS%BRNLAB(NVARY),User_LABELS%BRNREF(NVARY),User_LABELS%BRNMIN(NVARY),User_LABELS%BRNMAX(NVARY),   &
          User_LABELS%NGPVAR(NVARY),User_LABELS%KINDXS(NVARY,2),STAT=IOS                                             )
ELSE
 ALLOCATE(User_LABELS%BRNLAB(1),User_LABELS%BRNREF(1),User_LABELS%BRNMIN(1),User_LABELS%BRNMAX(1),   &
          User_LABELS%NGPVAR(1),User_LABELS%KINDXS(1,1),STAT=IOS)
ENDIF
IF (IOS .NE. 0) THEN
  WRITE(MODULE_OUT,105)
  WRITE(MODULE_OUT,'("[LABELS]...FAILED TO ALLOCATE LABELS DATA FOR CARD TYPE 09",57("."))')
  WRITE(MODULE_OUT,'("[LABELS]...NUMBER OF BURNUP DEPENDENT ISOTOPES......................(NVARY )",23("."),I16)') NVARY
  WRITE(MODULE_OUT,100)
  CALL Abort
END IF
User_LABELS%BRNLAB = 0.0
User_LABELS%BRNREF = 0.0
User_LABELS%BRNMIN = 0.0
User_LABELS%BRNMAX = 0.0
User_LABELS%NGPVAR = 0
User_LABELS%KINDXS = 0

! CARD TYPE 10
IF ((NVARY .GT. 0) .AND. (MAXBRN .GT. 0)) THEN
   ALLOCATE(User_LABELS%NUMGRP(MAXBRN,NVARY),User_LABELS%NORCAP(MAXBRN,NVARY),User_LABELS%NORFIS(MAXBRN,NVARY),STAT=IOS)
ELSE
   ALLOCATE(User_LABELS%NUMGRP(1,1),User_LABELS%NORCAP(1,1),User_LABELS%NORFIS(1,1),STAT=IOS)
END IF
IF (IOS .NE. 0) THEN
 WRITE(MODULE_OUT,105)
 WRITE(MODULE_OUT,'("[LABELS]...FAILED TO ALLOCATE LABELS DATA FOR CARD TYPE 10",57("."))')
 WRITE(MODULE_OUT,'("[LABELS]...NUMBER OF BURNUP DEPENDENT ISOTOPES......................(NVARY )",23("."),I16)') NVARY
 WRITE(MODULE_OUT,'("[LABELS]...MAXIMUM NUMBER OF BURNUP DEPENDENT GROUPS................(MAXBRN)",23("."),I16)') MAXBRN
 WRITE(MODULE_OUT,100)
 CALL Abort
END IF
User_LABELS%NUMGRP = 0
User_LABELS%NORCAP = 0
User_LABELS%NORFIS = 0

! CARD TYPE 11
IF ((NVARY .GT. 0) .AND. (MAXORD .GT. 0)) THEN
   ALLOCATE(User_LABELS%CFIT(MAXORD+1,MAXBRN,NVARY),User_LABELS%FFIT(MAXORD+1,MAXBRN,NVARY),STAT=IOS)
ELSE
   ALLOCATE(User_LABELS%CFIT(1,1,1),User_LABELS%FFIT(1,1,1),STAT=IOS)
END IF
IF (IOS .NE. 0) THEN
   WRITE(MODULE_OUT,105)
   WRITE(MODULE_OUT,'("[LABELS]...FAILED TO ALLOCATE LABELS DATA FOR CARD TYPE 11",57("."))')
   WRITE(MODULE_OUT,'("[LABELS]...HIGHEST ORDER POLYNOMIAL FIT.............................(MAXORD)",23("."),I16)') MAXORD
   WRITE(MODULE_OUT,'("[LABELS]...NUMBER OF BURNUP DEPENDENT ISOTOPES......................(NVARY )",23("."),I16)') NVARY
   WRITE(MODULE_OUT,'("[LABELS]...MAXIMUM NUMBER OF BURNUP DEPENDENT GROUPS................(MAXBRN)",23("."),I16)') MAXBRN
   WRITE(MODULE_OUT,100)
   CALL Abort
END IF
User_LABELS%CFIT = 0.0
User_LABELS%FFIT = 0.0

User_LABELS%Defined  = .TRUE.
User_LABELS%NTZSZ    =  NTZSZ
User_LABELS%NREG     =  NREG 
User_LABELS%NAREA    =  NAREA
User_LABELS%LREGA    =  LREGA
User_LABELS%NHTS1    =  NHTS1
User_LABELS%NHTS2    =  NHTS2
User_LABELS%NSETS    =  NSETS
User_LABELS%NALIAS   =  NALIAS
User_LABELS%NTRI     =  NTRI  
User_LABELS%NRING    =  NRING 
User_LABELS%NCHAN    =  NCHAN 
User_LABELS%NBANKS   =  NBANKS
User_LABELS%LINTAX   =  LINTAX
User_LABELS%MAXTIM   =  MAXTIM
User_LABELS%MAXROD   =  MAXROD
User_LABELS%MAXMSH   =  MAXMSH
User_LABELS%MAXLRD   =  MAXLRD
User_LABELS%MAXLCH   =  MAXLCH
User_LABELS%NVARY    =  NVARY
User_LABELS%MAXBRN   =  MAXBRN
User_LABELS%MAXORD   =  MAXORD
User_LABELS%ND       =  ND

END SUBROUTINE LABELS_Define

!---------------------------------------------------------------------------------------------------------------------------------
!  LABELS_Void(User_LABELS)
!  Deallocates the data
!---------------------------------------------------------------------------------------------------------------------------------
SUBROUTINE LABELS_Void(User_LABELS)
IMPLICIT NONE
TYPE (LABELS_DATA) User_LABELS  ! A user data variable to be Defined by reading in a LABELS file
! local
INTEGER(KIND=4) IOS

100 FORMAT('[LABELS]...SORRY, BUT I MUST STOP')
101 FORMAT('[LABELS]',107('.'))
102 FORMAT('')
105 FORMAT('[LABELS]...THERE WAS A FATAL ERROR THAT OCCURED IN (VOIDTYPE)',54('.'))

IF (User_LABELS%Defined) THEN
   DEALLOCATE( User_LABELS%CMPNAM,User_LABELS%SETISO,User_LABELS%RBPOS, User_LABELS%BRNREF,  &
               User_LABELS%REGNAM,User_LABELS%ALIAS, User_LABELS%NMESH, User_LABELS%BRNMIN,  &
               User_LABELS%ARANAM,User_LABELS%BNKLAB,User_LABELS%LENCHN,User_LABELS%BRNMAX,  &
               User_LABELS%NRA,   User_LABELS%ZMESHO,User_LABELS%LENROD,User_LABELS%NGPVAR,  &
               User_LABELS%HAFHT1,User_LABELS%POSBNK,User_LABELS%POSCHN,User_LABELS%KINDXS,  &
               User_LABELS%XTRAP1,User_LABELS%NRODS, User_LABELS%POSROD,User_LABELS%NUMGRP,  &
               User_LABELS%HAFHT2,User_LABELS%NTIMES,User_LABELS%MRCHN, User_LABELS%NORCAP,  &
               User_LABELS%XTRAP2,User_LABELS%KFINTO,User_LABELS%MRROD, User_LABELS%NORFIS,  &
               User_LABELS%BRNLAB,User_LABELS%RBTIME,User_LABELS%MESH,  User_LABELS%CFIT,    & 
               User_LABELS%FFIT,  STAT=IOS)
   IF (IOS .NE. 0) THEN
      WRITE(MODULE_OUT,105)
      WRITE(MODULE_OUT,'("[LABELS]...Failed to deallocate data structure memory")')
      WRITE(MODULE_OUT,100)
      CALL Abort
   END IF
   User_LABELS%Defined = .FALSE.
END IF

END SUBROUTINE LABELS_Void

END MODULE LABELS_io

